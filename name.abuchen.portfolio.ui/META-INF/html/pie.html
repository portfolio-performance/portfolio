<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="${/META-INF/css/THEME.css}">
</head>
<body>
<script src="${/META-INF/js/d3.min.js}"></script>
<script src="${/META-INF/js/pp.js}"></script>
<script>
window.addEventListener('load', createPie);

function createPie() {
var data = JSON.parse(loadData());
var total = d3.sum(data, function(d) {return d.value;} );

pp.onResizeEnd(function() {
    thePieChart.resize();
});

var thePieChart = {

    isInitialized: false,
    toPercent: d3.format("0.2%"),

    build: function () {
        this.width = pp.getInitialWidth();
        this.height = pp.getInitialHeight();
        this.radius = (Math.min(this.width, this.height) / 2) - 10;

        this.pie = d3.layout.pie()
            .startAngle(Math.PI / 2)
            .endAngle(2.5 * Math.PI)
            .value(function(d) { return d.value; })
            .sort(null);

        this.arc = d3.svg.arc()
            .innerRadius(this.radius / 2)
            .outerRadius(this.radius - 60);

        this.tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        this.svg = d3.select("body").append("svg")
            .attr("width", this.width)
            .attr("height", this.height)
            .append("g")
            .attr("transform", "translate(" + this.width / 2 + "," + this.height / 2 + ")");
    },

    resize: function() {
        var that = this;

        this.width = pp.getInnerWidth();
        this.height = pp.getInnerHeight();
        this.radius = (Math.min(this.width, this.height) / 2) - 10;

        this.arc = this.arc
            .innerRadius(this.radius / 2)
            .outerRadius(this.radius - 50);

        this.svg
            .attr("width", this.width)
            .attr("height", this.height)
            .attr("transform", "translate(" + this.width / 2 + "," + (this.height / 2) + ")");

        this.path
            .attr("d", this.arc)
            .transition();

        this.addLabels();

        this.valueLabels
            .attr("transform", this.transformValueLabels)
            .transition();
    },

    update: function(data) {
        var that = this;
        this.piedata = this.pie(data);

        var pathGroup = this.svg.select("g.piePaths");
        if (pathGroup.empty()) {
            pathGroup = this.svg.append("g").attr("class", "piePaths");
        }

        this.path = pathGroup.selectAll("path.pie")
            .data(this.piedata);

        // Enter: create new paths
        this.path.enter()
            .append("path")
            .attr("class", "pie")
            .attr("stroke", "#ffffff")
            .attr("fill", function(d) { return d.data.color; })
            .attr("d", this.arc)
            .on("mouseover", function(d) { that.mouseover(d); })
            .on("mousemove", function(d) { that.mousemove(d); })
            .on("mouseout", function(d) { that.mouseout(d); })
            .on("click", function(d) { that.click(d); });

        // Update: update existing paths to new values
        var pathUpdate = this.isInitialized ? this.path.transition().duration(300) : this.path;
        pathUpdate
            .attr("d", this.arc)
            .attr("fill", function(d) { return d.data.color; });

        // Exit: remove old paths
        this.path.exit()
            .transition()
            .duration(300)
            .style("opacity", 0)
            .remove();

        this.addLabels();
        this.addPercentageLabels();
        this.isInitialized = true;
    },

    addLabels: function() {
        var that = this;

        var labelGroup = this.svg.select("g.labels");
        if (labelGroup.empty()) {
            labelGroup = this.svg.append("g").attr("class", "labels");
        }

        // Filter data to only include items above threshold
        var labelData = this.piedata
            .filter(function(d) { return d.data.value / total > 0.001; })
            .sort(function(p1, p2) { return p1.startAngle - p2.startAngle; });

        var labels = labelGroup.selectAll("text")
            .data(labelData);

        // Enter: create new labels
        labels.enter()
            .append("text")
            .attr("text-anchor", "start")
            .attr("visibility", "hidden");

        // Exit: remove old labels
        labels.exit().remove();

        // label positioning algorithm (if we want to call it that):
        // on the right side, if it conflicts, move it below
        // on the left side, if it conflicts, move it up

        var previous;

        // Update: position all labels (both new and existing)
        labels
            .text(function(d) { return d.data.label; })
            .each(function(d, i) {
                var a = (d.startAngle + d.endAngle) / 2;
                var bbox = this.getBBox();
                var labelRadius = that.radius - 40;

                var isRight = (a >= 0 && a <= Math.PI) || (a >= 2 * Math.PI);

                d.cx = Math.sin(a) * (labelRadius);
                d.cy = -Math.cos(a) * (labelRadius);

                if (isRight) {
                    d.x = d.cx;
                    d.l = d.cx - 2;
                    d.r = d.cx + bbox.width + 2;
                } else {
                    d.x = d.cx - bbox.width;
                    d.l = d.cx - bbox.width - 2;
                    d.r = d.cx + 2;
                }
                d.y = d.cy;
                d.b = d.y;
                d.t = d.y - bbox.height;

                // check for conflict
                if (previous && d.l < previous.r && d.r > previous.l &&
                    d.t < previous.b && d.b > previous.t) {

                    if (isRight) {
                        d.t = previous.b - 2;
                        d.b = d.y = previous.b + bbox.height - 2;
                    } else {
                        d.t = previous.t - bbox.height - 2;
                        d.b = d.y = previous.t - 2;
                    }
                }

                previous = d;
            });

        // Apply transition only on updates, not on initial render
        var labelUpdate = this.isInitialized ? labels.transition().duration(300) : labels;
        labelUpdate
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; })
            .attr("visibility", "visible");
    },

    addPercentageLabels: function() {
        var that = this;

        var labelGroup = this.svg.select("g.values");
        if (labelGroup.empty()) {
            labelGroup = this.svg.append("g").attr("class", "values");
        }

        // Filter data to only include items above threshold
        var valueData = this.piedata
            .filter(function(d) { return d.data.value / total > 0.015; })
            .sort(function(p1, p2) { return p1.startAngle - p2.startAngle; });

        this.valueLabels = labelGroup.selectAll("text")
            .data(valueData);

        // Enter: create new value labels
        this.valueLabels.enter()
            .append("text")
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .on("mouseover", function(d) { that.mouseover(d); })
            .on("mousemove", function(d) { that.mousemove(d); })
            .on("mouseout", function(d) { that.mouseout(d); })
            .on("click", function(d) { that.click(d); });

        // Exit: remove old value labels
        this.valueLabels.exit().remove();

        // Update: update all value labels (both new and existing)
        this.valueLabels
            .text(function(d) { return d.data.valueLabel; })
            .style("fill", function(d) { return brightness(d3.rgb(d.data.color)) < 125 ? "#eee" : "#000"; });

        // Apply transition only on updates, not on initial render
        var valueUpdate = this.isInitialized ? this.valueLabels.transition().duration(300) : this.valueLabels;
        valueUpdate.attr("transform", this.transformValueLabels);
    },

    transformValueLabels: function(d) {
        indent = 3 * thePieChart.radius / 4 - 20;
        return "translate(" + ( indent * Math.sin( ((d.endAngle - d.startAngle) / 2) + d.startAngle ) )
                + "," + ( -1 * indent * Math.cos( ((d.endAngle - d.startAngle) / 2) + d.startAngle ) ) + ")";
    },

    mouseover: function(d) {
        this.tooltip
            .transition()
            .duration(250)
            .style("opacity", 1);

        this.tooltip
            .html(d.data.caption)
            .style("left", (d3.event.pageX + 6) + "px")
            .style("top", (d3.event.pageY - 20) + "px");
    },

    mousemove: function(d) {
        this.tooltip
            .style("left", (d3.event.pageX + 6) + "px")
            .style("top", (d3.event.pageY - 20) + "px");
    },

    mouseout: function(d) {
        this.tooltip.transition()
          .duration(250)
          .style("opacity", 0);
    },
    
    click: function(d) {
        if (typeof onItemSelected === 'function') {
            onItemSelected(d.data.uuid);
        }
    }
}

thePieChart.build();
thePieChart.update(data);

// expose global update function for external calls
window.updateChart = function() {
    var newData = JSON.parse(loadData());
    total = d3.sum(newData, function(d) { return d.value; });
    thePieChart.update(newData);
};

// http://www.w3.org/WAI/ER/WD-AERT/#color-contrast
function brightness(rgb) {
  return rgb.r * .299 + rgb.g * .587 + rgb.b * .114;
}
}
</script>
</body>
</html>
